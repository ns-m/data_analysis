/*select * from courier_actions limit 10*/
/*select action, courier_id, order_id, time from courier_actions limit 12*/
/*select * from user_actions limit 10*/
/*select user_id, action, order_id, time from user_actions order by user_id desc limit 10*/
/*select user_id, birth_date, sex from users order by birth_date desc limit 5*/
--select product_id, name, price from products order by price desc limit 10
--SELECT name, price, product_id FROM products
--SELECT product_id, name, price FROM products ORDER BY name
--SELECT courier_id, order_id, action, time FROM courier_actions ORDER BY courier_id, action, time DESC LIMIT 1000
--SELECT name, price FROM products ORDER BY price DESC LIMIT 5
--SELECT name product_name, price product_price FROM products ORDER BY price DESC LIMIT 5
--SELECT name, LENGTH(name) name_length, price FROM products ORDER BY name_length DESC LIMIT 1
--SELECT name, UPPER(SPLIT_PART(name, ' ', 1)) AS first_word, price FROM products ORDER BY name
--SELECT CAST('100' AS INTEGER);
--SELECT '2022-12-31'::DATE
--SELECT name, price, price::VARCHAR price_char FROM products ORDER BY name
--SELECT CONCAT('Заказ № ', order_id, ' создан ', DATE(creation_time)) AS order_info FROM orders LIMIT 200
--SELECT DATE_PART('year', DATE '2022-01-12');
/*SELECT DATE_PART('month', DATE '2022-01-12');
SELECT DATE_PART('day', DATE '2022-01-12');
SELECT DATE_PART('hour', TIMESTAMP '2022-01-12 20:31:05');
SELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05');*/
--SELECT courier_id, DATE_PART('year', birth_date) AS birth_year FROM couriers ORDER BY birth_year DESC,  courier_id
--SELECT courier_id, COALESCE(DATE_PART('year', birth_date)::VARCHAR, 'unknown') AS birth_year FROM couriers ORDER BY birth_year DESC,  courier_id
--SELECT product_id, name, price AS old_price, price*1.05 AS new_price FROM products ORDER BY new_price DESC, product_id
--SELECT product_id, name, price AS old_price, round(price*1.05, 1) AS new_price FROM products ORDER BY new_price DESC, product_id
/*SELECT product_id, name, price AS old_price,
    CASE
    when price > 100 and name != 'икра' then price*1.05
    ELSE price
    END AS new_price 
FROM products ORDER BY new_price DESC, product_id*/
/*SELECT
  product_id,
  name,
  price,
  round((price / 120 * 20), 2) as tax,
  round(price - (price / 120 * 20), 2) as price_before_tax
FROM
  products
ORDER BY
  price_before_tax DESC,
  product_id*/
--SELECT product_id, name, price FROM products WHERE price <= 100 ORDER BY product_id
--SELECT user_id FROM users WHERE sex = 'female' ORDER BY user_id LIMIT 1000
--SELECT user_id, order_id, time FROM user_actions WHERE time > '2022-09-06' AND action = 'create_order' ORDER BY order_id
/*SELECT
  product_id,
  name,
  price AS old_price,
  (price * 0.8) AS new_price
FROM
  products
WHERE
  (price * 0.8) > 100
ORDER by
  product_id*/
/*SELECT
  product_id,
  name
FROM
  products
WHERE
  SPLIT_PART(name, ' ', 1) = 'чай'
  OR LENGTH(name) = 5 
ORDER BY product_id  */
/*SELECT
  product_id,
  name
FROM
  products
WHERE
  name LIKE '%чай%'
ORDER BY
  product_id*/
/*SELECT
  product_id,
  name
FROM
  products
WHERE
  name LIKE 'с%'
  AND name NOT LIKE '% %'
ORDER BY
  product_id*/
/*SELECT
  product_id,
  name,
  price,
  '25%' AS discount,
  (price*0.75) AS new_price
FROM
  products
WHERE
  price > 60
  AND name LIKE '%чай %'
ORDER BY product_id  */
/*SELECT
  user_id,
  order_id,
  action,
  time
FROM
  user_actions
WHERE user_id IN (170, 200, 230)
  AND time BETWEEN '2022-08-25' AND '2022-09-05'
ORDER BY order_id DESC  */
/*SELECT user_id,
       birth_date
FROM   users
WHERE  sex = 'male'
   and birth_date is not null
ORDER BY birth_date desc limit 50*/
/*SELECT
  order_id,
  time
FROM
  courier_actions
WHERE
  courier_id = 100
  AND action = 'deliver_order'
ORDER BY
  time DESC
LIMIT
  10*/
/*SELECT 
  order_id
FROM 
  user_actions
WHERE
  DATE_PART('month', time) = 08
  AND action = 'create_order'
  and date_part('year', time) = 2022
ORDER BY
  order_id*/
/*SELECT
  courier_id
FROM
  couriers
WHERE
  birth_date BETWEEN '1990-01-01' AND '1996-01-01'
ORDER BY
  courier_id*/
/*SELECT courier_id
FROM   couriers
WHERE  date_part('year', birth_date) between 1990
   and 1995
ORDER BY courier_id  */
/*SELECT
  user_id,
  order_id,
  action,
  time
FROM
  user_actions
WHERE
  DATE_PART('dow', time) = 3
  AND time BETWEEN '2022-08-01' AND '2022-09-01'
  AND date_part('hour', time) between 12
   and 15
  AND action = 'cancel_order'
ORDER BY
  order_id DESC*/
/*SELECT 
  user_id,
  order_id,
  action,
  time
FROM   user_actions
WHERE  action = 'cancel_order'
   and date_part ('dow', time) = 3
   and date_part ('month' , time) = 8
   and date_part('hour', time) between 12
   and 15
   and date_part('year', time) = 2022
ORDER BY order_id desc*/
/*SELECT
  product_id,
  name,
  price,
  CASE
    WHEN name IN (
      'сахар',
      'сухарики',
      'сушки',
      'семечки',
      'масло льняное',
      'виноград',
      'масло оливковое',
      'арбуз',
      'батон',
      'йогурт',
      'сливки',
      'гречка',
      'овсянка',
      'макароны',
      'баранина',
      'апельсины',
      'бублики',
      'хлеб',
      'горох',
      'сметана',
      'рыба копченая',
      'мука',
      'шпроты',
      'сосиски',
      'свинина',
      'рис',
      'масло кунжутное',
      'сгущенка',
      'ананас',
      'говядина',
      'соль',
      'рыба вяленая',
      'масло подсолнечное',
      'яблоки',
      'груши',
      'лепешка',
      'молоко',
      'курица',
      'лаваш',
      'вафли',
      'мандарины'
    ) THEN round(price/110*10, 2)
    ELSE round(price/120*20, 2)
    END AS tax,
    CASE
    WHEN name IN (
      'сахар',
      'сухарики',
      'сушки',
      'семечки',
      'масло льняное',
      'виноград',
      'масло оливковое',
      'арбуз',
      'батон',
      'йогурт',
      'сливки',
      'гречка',
      'овсянка',
      'макароны',
      'баранина',
      'апельсины',
      'бублики',
      'хлеб',
      'горох',
      'сметана',
      'рыба копченая',
      'мука',
      'шпроты',
      'сосиски',
      'свинина',
      'рис',
      'масло кунжутное',
      'сгущенка',
      'ананас',
      'говядина',
      'соль',
      'рыба вяленая',
      'масло подсолнечное',
      'яблоки',
      'груши',
      'лепешка',
      'молоко',
      'курица',
      'лаваш',
      'вафли',
      'мандарины'
    ) THEN round(price-(price/110*10), 2)
    ELSE round(price-(price/120*20), 2)
    END AS price_before_tax
    FROM
      products
    ORDER BY
      price_before_tax DESC,
      product_id*/
--SELECT DISTINCT user_id FROM user_actions ORDER BY user_id
/*SELECT
  DISTINCT courier_id,
  order_id
FROM
  courier_actions
ORDER BY
  courier_id,
  order_id*/
--SELECT MAX(price) AS max_price, MIN(price) AS min_price FROM products
--SELECT COUNT(*) AS dates, COUNT(birth_date) AS dates_not_null FROM users
/*SELECT
  COUNT(user_id) users,
  COUNT(DISTINCT user_id) unique_users
FROM
  user_actions*/
--SELECT COUNT(courier_id) AS couriers FROM couriers WHERE sex = 'female'
/*SELECT
  MIN(time) AS first_delivery,
  MAX(time) AS last_delivery
FROM
  courier_actions
WHERE
  action = 'deliver_order'*/
--SELECT SUM(price) AS order_price FROM products  WHERE name IN ('сухарики', 'чипсы', 'энергетический напиток')
--SELECT name FROM products WHERE name LIKE '% напиток%'
--SELECT COUNT(order_id) AS orders FROM orders WHERE array_length(product_ids, 1) >= 9
/*SELECT
  SUM(
  CASE
  WHEN name = 'сухарики' THEN price * 3
  WHEN name = 'чипсы' THEN price * 2
  WHEN name = 'энергетический напиток' THEN price
  END
  ) AS order_price
FROM
  products*/
/*SELECT
  ROUND(AVG(price), 2) AS avg_price
FROM
  products
WHERE
  name NOT IN ('иван-чай', 'чайный гриб')
  AND (
    name LIKE 'чай%'
    OR name LIKE 'кофе%'
  )*/
--SELECT AGE(MAX(birth_date), MIN(birth_date))::VARCHAR AS age_diff FROM users WHERE sex = 'male'
/*SELECT
  ROUND(AVG(array_length(product_ids, 1)), 2) AS avg_order_size
FROM
  orders
WHERE
  date_part('dow', creation_time) IN (0, 6)*/
/*SELECT
  COUNT(DISTINCT user_id) AS unique_users,
  COUNT(DISTINCT order_id) AS unique_orders,
  ROUND(COUNT(DISTINCT order_id):: DECIMAL / COUNT(DISTINCT user_id), 2) AS orders_per_user
FROM
  user_actions*/
SELECT
  COUNT(DISTINCT user_id) - (COUNT(DISTINCT user_id) FILTER (
    WHERE
      action = 'cancel_order'
  )) AS users_count
FROM
  user_actions
--SELECT * FROM user_actions LIMIT 50
 


Правильный порядок операторов в запросе выглядит так:

SELECT -- перечисление полей результирующей таблицы
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей

Сейчас важно запомнить порядок записи всех известных нам ключевых слов:

    SELECT
    FROM
    ORDER BY
    LIMIT

Также важно понять, что порядок их выполнения несколько отличается от того, в какой последовательности они указываются в SQL-запросе:

    Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
    Затем SELECT — отбираются указанные столбцы.
    Потом ORDER BY — производится сортировка результирующей таблицы.
    И в самом конце LIMIT — ограничивается количество выводимых записей.

На вход функции CAST необходимо подать имя колонки, указав через AS тип данных, к которому нужно привести все значения:
SELECT CAST(column AS VARCHAR)
FROM table
Также изменить тип данных можно с помощью специального синтаксиса с двумя двоеточиями («::»):
SELECT column::VARCHAR
FROM table

Функция CONCAT принимает на вход несколько аргументов и возвращает результат их последовательного сложения друг с другом. Хорошая аналогия — составление предложений из разных карточек со словами:
SELECT CONCAT('SQL', ' ', 'Simulator ', 2022)

Результат:
SQL Simulator 2022

На практике часто встречаются задачи, когда нужна, например, не вся дата, а какая-то её часть: год, месяц, день, час и т.д. Извлечь эту часть из исходных данных позволяет функция DATE_PART. Её синтаксис следующий:
SELECT DATE_PART(part, column)
На месте part необходимо в кавычках указать ту часть, которую нужно извлечь: 'year', 'month', 'day', 'hour' и т.д. На месте column следует указать нужную колонку либо конкретную дату или время.

Работу COALESCE можно описать следующим образом: она буквально читает список значений слева направо и, как только видит значение, которое не является NULL, сразу же возвращает его и прекращает чтение списка. Посмотрите внимательно на следующие примеры:
SELECT COALESCE(NULL, 'I am not NULL' , 'karpov.courses')
Результат:
I am not NULL

SELECT COALESCE(NULL, 25, 100, 150)
Результат:
25

SELECT COALESCE('NULL', 'I am not NULL', 'karpov.courses')
Результат:
NULL

Одним из аргументов функции COALESCE может выступать результат выполнения другой функции:
SELECT COALESCE(NULL, LOWER('I am not NULL'), 'karpov.courses')

Результат:
i am not null

Чтобы заполнить пропуски в колонке, достаточно применить функцию COALESCE к колонке с пропусками и указать в качестве второго аргумента то значение, которое мы хотим видеть вместо NULL:
SELECT COALESCE(column, 'filler value')
FROM table

Функция COALESCE применится к каждому значению в колонке. Если это значение окажется NULL, она заменит его на значение, указанное вторым аргументом. Если значение в колонке, наоборот, окажется не NULL, то функция просто вернёт это значение.
При этом к колонке с пропусками можно также заранее применять разные другие функции:
SELECT COALESCE(LEFT(column, 5), 'filler value')
FROM table

Наряду с арифметическими операторами в PostgreSQL также доступны разные математические функции. Например, для округления вещественных чисел («чисел с плавающей точкой») можно использовать ROUND:
SELECT ROUND(100.5454, 2)
Результат:
100.55

SELECT ROUND(100.551, 1)
Результат:
100.6

SELECT ROUND(100.5511)
Результат:
101.0

Следующая конструкция разобъёт весь список наименований на три категории: «мясо», «рыба» и «другое». Соответственно, если в первых двух условиях мы не учтём какие-то наименования из колонки name (например, «телятину»), то они попадут в категорию «другое».
SELECT name,
       CASE 
       WHEN name='свинина' OR name='баранина' OR name='курица' THEN 'мясо'
       WHEN name='треска' OR name='форель' OR name='окунь' THEN 'рыба'
       ELSE 'другое'
       END AS сategory
FROM table

Результатом этих логических операций также могут быть три вышеуказанных логических состояния (TRUE, FALSE или NULL):
a	b	a AND b	a OR b
TRUE	TRUE	TRUE	TRUE
TRUE	FALSE	FALSE	TRUE
TRUE	NULL	NULL	TRUE
FALSE	FALSE	FALSE	FALSE
FALSE	NULL	FALSE	NULL
NULL	NULL	NULL	NULL
a	NOT a
TRUE	FALSE
FALSE	TRUE
NULL	NULL

существуют приоритеты выполнения операций:
1. умножение и деление (* и /)
2. сложение и вычитание (+ и -)
3. операторы сравнения (=, !=, >, <, >=, <=)
4. NOT
5. AND
6. OR

В SQL для фильтрации данных используется оператор WHERE. После оператора WHERE указывается логическое выражение, результат которого определяет, будет ли строка включена в результирующую таблицу. Если условие оказывается истинным (TRUE), то строка включается в результат, если ложным (FALSE) — строка исключается.

Таким образом, каждая строка в таблице проходит проверку на соответствие определённому условию, и в результате этих проверок формируется таблица, над которой затем проводятся операции, указанные в блоке SELECT.

Оператор WHERE и логическое выражение указываются после блока FROM:
SELECT column_1, column_2
FROM table
WHERE column_2 >= 0

В свою очередь операторы ORDER BY и LIMIT записываются уже после оператора WHERE. Если добавить их в пример выше, то запрос будет выглядеть так:
SELECT column_1, column_2
FROM table
WHERE column_2 >= 0
ORDER BY column_1
LIMIT 100
В результате мы сначала отфильтруем необходимые нам строки, затем выберем столбцы, отмеченные в SELECT, а потом отсортируем результирующую таблицу, ограничив число выводимых записей.

Таким образом, порядок записи известных нам на текущий момент ключевых слов выглядит так:

    SELECT
    FROM
    WHERE
    ORDER BY
    LIMIT

Снова обратим внимание, что порядок их выполнения отличается от того, в какой последовательности они указываются в запросе:

    Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
    Далее WHERE — отфильтровываются строки, соответствующие условию.
    Затем SELECT — отбираются указанные столбцы и применяются функции.
    Потом ORDER BY — производится сортировка результирующей таблицы.
    И в самом конце LIMIT — ограничивается количество выводимых записей.

Иными словами, в результате выполнения запроса сначала происходит подготовка таблицы к работе, а уже затем над ней выполняются разные операции.

После оператора WHERE к колонкам можно также применять разные функции:
SELECT column_1, column_2
FROM table 
WHERE LOWER(column_1) = 'karpov.courses'

В примере выше каждое значение в колонке column_1 сначала будет приведено к нижнему регистру, а затем сопоставлено со значением 'karpov.courses'. При этом в результат будут включены исходные значения в колонке column_1. Таким образом, функция послужит только для фильтрации записей, но на сами значения в колонках никак не повлияет.

Обратите внимание, что использовать алиасы, присвоенные колонкам в операторе SELECT, всё так же нельзя. Следующий запрос вернёт ошибку:
-- Этот запрос вернёт ошибку:

SELECT column_1 AS new_column_1, column_2
FROM table 
WHERE LOWER(new_column_1) = 'karpov.courses'

 Для фильтрации по колонкам с текстовыми значениями в SQL предусмотрен оператор LIKE.

Оператор LIKE не просто сравнивает строки на полное совпадение (или несовпадение), а проверяет их на соответствие заданному шаблону: если строка ему соответствует, то возвращается TRUE, в противном случае — FALSE. Как можно догадаться, конструкция NOT LIKE работает с точностью до наоборот.

Шаблоны могут содержать как обычные символы, так и символы-шаблоны: знак процента ( % ) и подчёркивание ( _ ). Подчёркивание подменяет любой одиночный символ, а знак процента — любую (в том числе и пустую) последовательность символов:
SELECT 'karpov.courses' LIKE 'karpov%'
Результат:
true

SELECT 'karpov.courses' LIKE 'karpov_'
Результат:
false

SELECT 'karpov.courses' LIKE '%karpov%'
Результат:
true

SELECT 'karpov.courses' LIKE '_karpov%'
Результат:
false

SELECT 'karpov.courses' LIKE '%.%'
Результат:
true

SELECT 'karpov.courses' LIKE '_._'
Результат:
false

SELECT 'karpov.courses' LIKE 'Karpov%'
Результат:
false

Оператор IN проверяет, соответствует ли значение в колонке одному из значений из заданного списка. Иными словами, он проверяет, входит ли значение в этот список:
SELECT column_1, column_2
FROM table
WHERE column_1 IN ('product_1', 'product_2', 'product_3')

В свою очередь оператор BETWEEN позволяет отобрать данные, относящиеся к некоторому интервалу. При этом границы интервала включаются:
SELECT column_1, column_2
FROM table
WHERE column_2 BETWEEN 5 AND 10

Оператор BETWEEN можно использовать и для фильтрации по колонкам с датами и временем
SELECT column_1, column_2, column_3
FROM table
WHERE column_3 BETWEEN '2022-11-20' AND '2022-12-31'

Для получения обратного результата в сочетании с операторами IN и BETWEEN можно использовать оператор NOT:
SELECT column_1, column_2
FROM table
WHERE column_1 NOT IN ('product_1', 'product_2', 'product_3')


SELECT column_1, column_2
FROM table
WHERE column_2 NOT BETWEEN 5 AND 10

Для проверки на NULL значения в SQL есть оператор IS NULL. В сочетании с WHERE записывается он так:
SELECT column_1, column_2
FROM table
WHERE column_1 IS NULL

Если же, наоборот, необходимо отобрать не NULL значения, то дополнительно используется оператор NOT:
SELECT column_1, column_2
FROM table
WHERE column_1 IS NOT NULL

Ключевое слово DISTINCT позволяет отбирать уникальные записи, т.е. избавляться от всех дубликатов в таблице.

Указывается DISTINCT сразу после SELECT. Для вывода уникальных значений в одной колонке можно составить следующий запрос:
SELECT DISTINCT column
FROM table

запрос для двух колонок будет выглядеть так:
SELECT DISTINCT column_1, column_2
FROM table
В таком случае в качестве результата запрос вернёт уникальные комбинации значений в колонках. 

Агрегирующими функциями называют функции, которые обрабатывают определённый набор строк и возвращают одно обобщающее значение. Если вы когда-нибудь работали в Excel, то наверняка сталкивались с подсчётом суммы или максимального/минимального значения по столбцу — речь идёт именно об этом.

Вот несколько примеров таких функций в SQL:

    COUNT — считает количество значений в колонке.
    SUM — вычисляет сумму значений.
    AVG — вычисляет среднее значение.
    MAX — вычисляет максимальное значение.
    MIN — вычисляет минимальное значение.
Пример:
SELECT COUNT(column) AS count
FROM table


SELECT SUM(column_1) AS sum,
       AVG(column_2) AS average
FROM table

важно учитывать один нюанс: запрос со звёздочкой возвращает количество вообще всех записей в таблице, а запрос с указанием столбца — количество тех записей, где в заданном столбце значения не являются NULL.

Таким образом, если в некоторой колонке column есть пропуски, выражения COUNT(*) и COUNT(column) вернут разные значения.

агрегирующие функции можно применять в сочетании с ключевым словом DISTINCT. В таком случае расчёты будут производиться только по уникальным значениям.

Если в случае с MIN и MAX это не имеет особого смысла, то при расчёте AVG, SUM и COUNT иногда это бывает полезно:
SELECT SUM(DISTINCT column) AS sum_distinct
FROM table

При этом довольно часто DISTINCT используется именно в сочетании с COUNT — для подсчёта числа уникальных пользователей, уникальных заказов и т.д.
SELECT COUNT(DISTINCT column) AS count_distinct
FROM table

Функция array_length вычисляет количество элементов в массиве (длину массива) и записывается следующим образом:
SELECT array_length(ARRAY[1,2,3], 1)
Результат:
3
Единица в качестве второго аргумента — это размерность массива, по которой считается его длина. Так как список у нас одноразмерный (просто значения, записанные в одну строчку), то выбор у нас невелик — можем указать только первую размерность.
Если бы у нас была таблица N x N, в которой были бы и строки, и столбцы, то размерности было бы две: первая соответствовала бы количеству строк, а вторая — числу столбцов. В таком случае мы могли бы указать либо первую, либо вторую размерность.
 _______
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
 ‾‾‾‾‾‾‾
В этой таблице 3 строки и 2 столбца, поэтому её можно описать в виде следующего списка из трёх вложенных в него списков:
ARRAY[[1,2], [3,4], [5,6]]
В примере выше количество списков внутри основного списка — это количество строк в таблице, а количество элементов внутри каждого внутреннего списка — это количество столбцов.

Обратите внимание на результат вычислений функции array_length для первой и второй размерностей:
SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)
Результат:
3

SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)
Результат:
2

В качестве аргумента агрегирующих функций могут выступать не только столбцы, но также расчётные колонки или результат другой функции:
SELECT AVG(some_function(column))
FROM table
SELECT AVG(column_1 + column_2)
FROM table

Функция AGE возвращает разницу между двумя значениями, представленными в формате TIMESTAMP. При этом из первого значения вычитается второе, а сама разница получается в формате INTERVAL:
SELECT AGE('2022-12-12', '2021-11-10')
Результат:
397 days, 0:00:00

Если в качестве первого аргумента не указать ничего, то на место первой даты автоматически подставится текущая дата (полночь текущего дня, т.е. начало дня). 
текущей дате соответствует значение current_date, которое можно указывать в качестве аргумента функции AGE: 
SELECT AGE(current_date, '2021-11-10')
Результат:
397 days, 0:00:00

чтобы результат отображался не в виде количества дней, а в более удобном формате, можно переводить результат вычислений в тип VARCHAR:
SELECT AGE(current_date, '2021-11-10')::VARCHAR
Результат:
1 year 1 mon 2 days

Аргументом агрегирующей функции может быть и более сложная расчётная колонка — например, полученная в результате работы конструкции CASE.
В таком случае сама конструкция CASE помещается внутрь скобок агрегирующей функции:
AVG(
    CASE  
    WHEN logical_expression_1 THEN expression_1
    WHEN logical_expression_2 THEN expression_2
    ELSE expression_else
    END
)
Так, если бы в нашей таблице все товары были разбиты по категориям и мы захотели бы посчитать среднюю цену товаров с учётом повышающих или понижающих коэффициентов для каждой категории, то мы могли бы сделать это, например, следующим образом:
SELECT AVG(
    CASE 
    WHEN category='мясо' THEN price*0.95
    WHEN category='рыба' THEN price*0.9
    WHEN category='напитки' THEN price*1.05
    ELSE price
    END
    ) AS avg_price
FROM products

Результаты нескольких агрегирующих функций можно использовать в одном запросе для проведения над ними арифметических операций:
SELECT (SUM(column_1) + SUM(column_2)) / 2
FROM table

познакомимся с более продвинутым функционалом — агрегатными выражениями с фильтрацией.
Если после агрегирующей функции указать ключевое слово FILTER и поместить в скобках некоторое условие condition после WHERE, то агрегирующей функции на вход будут поданы только те строки, для которых условие фильтра окажется истинным.
В общем виде эта конструкция выглядит так:
SELECT agg_function(column) FILTER (WHERE condition)
FROM table
Например, если бы мы захотели посчитать среднюю цену только для товаров категории 'рыба', то запрос выглядел бы так:
SELECT AVG(price) FILTER (WHERE category = 'рыба') AS avg_fish_price
FROM table

Обратите внимание: это очень похоже на обычную фильтрацию с агрегацией, которую мы рассматривали в предыдущих задачах, только в данном случае условие на отбор записей указывается сразу в блоке SELECT.
Преимущество такой записи в том, что она позволяет проводить расчёты без промежуточных запросов с условиями в блоке WHERE.