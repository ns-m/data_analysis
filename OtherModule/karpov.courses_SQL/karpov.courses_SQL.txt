/*select * from courier_actions limit 10*/
/*select action, courier_id, order_id, time from courier_actions limit 12*/
/*select * from user_actions limit 10*/
/*select user_id, action, order_id, time from user_actions order by user_id desc limit 10*/
/*select user_id, birth_date, sex from users order by birth_date desc limit 5*/
--select product_id, name, price from products order by price desc limit 10
--SELECT name, price, product_id FROM products
--SELECT product_id, name, price FROM products ORDER BY name
--SELECT courier_id, order_id, action, time FROM courier_actions ORDER BY courier_id, action, time DESC LIMIT 1000
--SELECT name, price FROM products ORDER BY price DESC LIMIT 5
--SELECT name product_name, price product_price FROM products ORDER BY price DESC LIMIT 5
--SELECT name, LENGTH(name) name_length, price FROM products ORDER BY name_length DESC LIMIT 1
--SELECT name, UPPER(SPLIT_PART(name, ' ', 1)) AS first_word, price FROM products ORDER BY name
--SELECT CAST('100' AS INTEGER);
--SELECT '2022-12-31'::DATE
--SELECT name, price, price::VARCHAR price_char FROM products ORDER BY name
--SELECT CONCAT('Заказ № ', order_id, ' создан ', DATE(creation_time)) AS order_info FROM orders LIMIT 200
--SELECT DATE_PART('year', DATE '2022-01-12');
/*SELECT DATE_PART('month', DATE '2022-01-12');
SELECT DATE_PART('day', DATE '2022-01-12');
SELECT DATE_PART('hour', TIMESTAMP '2022-01-12 20:31:05');
SELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05');*/
--SELECT courier_id, DATE_PART('year', birth_date) AS birth_year FROM couriers ORDER BY birth_year DESC,  courier_id
--SELECT courier_id, COALESCE(DATE_PART('year', birth_date)::VARCHAR, 'unknown') AS birth_year FROM couriers ORDER BY birth_year DESC,  courier_id
--SELECT product_id, name, price AS old_price, price*1.05 AS new_price FROM products ORDER BY new_price DESC, product_id
--SELECT product_id, name, price AS old_price, round(price*1.05, 1) AS new_price FROM products ORDER BY new_price DESC, product_id
/*SELECT product_id, name, price AS old_price,
    CASE
    when price > 100 and name != 'икра' then price*1.05
    ELSE price
    END AS new_price 
FROM products ORDER BY new_price DESC, product_id*/
/*SELECT
  product_id,
  name,
  price,
  round((price / 120 * 20), 2) as tax,
  round(price - (price / 120 * 20), 2) as price_before_tax
FROM
  products
ORDER BY
  price_before_tax DESC,
  product_id*/
--SELECT product_id, name, price FROM products WHERE price <= 100 ORDER BY product_id
--SELECT user_id FROM users WHERE sex = 'female' ORDER BY user_id LIMIT 1000
--SELECT user_id, order_id, time FROM user_actions WHERE time > '2022-09-06' AND action = 'create_order' ORDER BY order_id
/*SELECT
  product_id,
  name,
  price AS old_price,
  (price * 0.8) AS new_price
FROM
  products
WHERE
  (price * 0.8) > 100
ORDER by
  product_id*/
/*SELECT
  product_id,
  name
FROM
  products
WHERE
  SPLIT_PART(name, ' ', 1) = 'чай'
  OR LENGTH(name) = 5 
ORDER BY product_id  */
/*SELECT
  product_id,
  name
FROM
  products
WHERE
  name LIKE '%чай%'
ORDER BY
  product_id*/
/*SELECT
  product_id,
  name
FROM
  products
WHERE
  name LIKE 'с%'
  AND name NOT LIKE '% %'
ORDER BY
  product_id*/
/*SELECT
  product_id,
  name,
  price,
  '25%' AS discount,
  (price*0.75) AS new_price
FROM
  products
WHERE
  price > 60
  AND name LIKE '%чай %'
ORDER BY product_id  */
/*SELECT
  user_id,
  order_id,
  action,
  time
FROM
  user_actions
WHERE user_id IN (170, 200, 230)
  AND time BETWEEN '2022-08-25' AND '2022-09-05'
ORDER BY order_id DESC  */
/*SELECT user_id,
       birth_date
FROM   users
WHERE  sex = 'male'
   and birth_date is not null
ORDER BY birth_date desc limit 50*/
/*SELECT
  order_id,
  time
FROM
  courier_actions
WHERE
  courier_id = 100
  AND action = 'deliver_order'
ORDER BY
  time DESC
LIMIT
  10*/
/*SELECT 
  order_id
FROM 
  user_actions
WHERE
  DATE_PART('month', time) = 08
  AND action = 'create_order'
  and date_part('year', time) = 2022
ORDER BY
  order_id*/
/*SELECT
  courier_id
FROM
  couriers
WHERE
  birth_date BETWEEN '1990-01-01' AND '1996-01-01'
ORDER BY
  courier_id*/
/*SELECT courier_id
FROM   couriers
WHERE  date_part('year', birth_date) between 1990
   and 1995
ORDER BY courier_id  */
/*SELECT
  user_id,
  order_id,
  action,
  time
FROM
  user_actions
WHERE
  DATE_PART('dow', time) = 3
  AND time BETWEEN '2022-08-01' AND '2022-09-01'
  AND date_part('hour', time) between 12
   and 15
  AND action = 'cancel_order'
ORDER BY
  order_id DESC*/
/*SELECT 
  user_id,
  order_id,
  action,
  time
FROM   user_actions
WHERE  action = 'cancel_order'
   and date_part ('dow', time) = 3
   and date_part ('month' , time) = 8
   and date_part('hour', time) between 12
   and 15
   and date_part('year', time) = 2022
ORDER BY order_id desc*/
/*SELECT
  product_id,
  name,
  price,
  CASE
    WHEN name IN (
      'сахар',
      'сухарики',
      'сушки',
      'семечки',
      'масло льняное',
      'виноград',
      'масло оливковое',
      'арбуз',
      'батон',
      'йогурт',
      'сливки',
      'гречка',
      'овсянка',
      'макароны',
      'баранина',
      'апельсины',
      'бублики',
      'хлеб',
      'горох',
      'сметана',
      'рыба копченая',
      'мука',
      'шпроты',
      'сосиски',
      'свинина',
      'рис',
      'масло кунжутное',
      'сгущенка',
      'ананас',
      'говядина',
      'соль',
      'рыба вяленая',
      'масло подсолнечное',
      'яблоки',
      'груши',
      'лепешка',
      'молоко',
      'курица',
      'лаваш',
      'вафли',
      'мандарины'
    ) THEN round(price/110*10, 2)
    ELSE round(price/120*20, 2)
    END AS tax,
    CASE
    WHEN name IN (
      'сахар',
      'сухарики',
      'сушки',
      'семечки',
      'масло льняное',
      'виноград',
      'масло оливковое',
      'арбуз',
      'батон',
      'йогурт',
      'сливки',
      'гречка',
      'овсянка',
      'макароны',
      'баранина',
      'апельсины',
      'бублики',
      'хлеб',
      'горох',
      'сметана',
      'рыба копченая',
      'мука',
      'шпроты',
      'сосиски',
      'свинина',
      'рис',
      'масло кунжутное',
      'сгущенка',
      'ананас',
      'говядина',
      'соль',
      'рыба вяленая',
      'масло подсолнечное',
      'яблоки',
      'груши',
      'лепешка',
      'молоко',
      'курица',
      'лаваш',
      'вафли',
      'мандарины'
    ) THEN round(price-(price/110*10), 2)
    ELSE round(price-(price/120*20), 2)
    END AS price_before_tax
    FROM
      products
    ORDER BY
      price_before_tax DESC,
      product_id*/
--SELECT DISTINCT user_id FROM user_actions ORDER BY user_id
/*SELECT
  DISTINCT courier_id,
  order_id
FROM
  courier_actions
ORDER BY
  courier_id,
  order_id*/
--SELECT MAX(price) AS max_price, MIN(price) AS min_price FROM products
--SELECT COUNT(*) AS dates, COUNT(birth_date) AS dates_not_null FROM users
/*SELECT
  COUNT(user_id) users,
  COUNT(DISTINCT user_id) unique_users
FROM
  user_actions*/
--SELECT COUNT(courier_id) AS couriers FROM couriers WHERE sex = 'female'
/*SELECT
  MIN(time) AS first_delivery,
  MAX(time) AS last_delivery
FROM
  courier_actions
WHERE
  action = 'deliver_order'*/
--SELECT SUM(price) AS order_price FROM products  WHERE name IN ('сухарики', 'чипсы', 'энергетический напиток')
--SELECT name FROM products WHERE name LIKE '% напиток%'
--SELECT COUNT(order_id) AS orders FROM orders WHERE array_length(product_ids, 1) >= 9
/*SELECT
  SUM(
  CASE
  WHEN name = 'сухарики' THEN price * 3
  WHEN name = 'чипсы' THEN price * 2
  WHEN name = 'энергетический напиток' THEN price
  END
  ) AS order_price
FROM
  products*/
/*SELECT
  ROUND(AVG(price), 2) AS avg_price
FROM
  products
WHERE
  name NOT IN ('иван-чай', 'чайный гриб')
  AND (
    name LIKE 'чай%'
    OR name LIKE 'кофе%'
  )*/
--SELECT AGE(MAX(birth_date), MIN(birth_date))::VARCHAR AS age_diff FROM users WHERE sex = 'male'
/*SELECT
  ROUND(AVG(array_length(product_ids, 1)), 2) AS avg_order_size
FROM
  orders
WHERE
  date_part('dow', creation_time) IN (0, 6)*/
/*SELECT
  COUNT(DISTINCT user_id) AS unique_users,
  COUNT(DISTINCT order_id) AS unique_orders,
  ROUND(COUNT(DISTINCT order_id):: DECIMAL / COUNT(DISTINCT user_id), 2) AS orders_per_user
FROM
  user_actions*/
/*SELECT
  COUNT(DISTINCT user_id) - (COUNT(DISTINCT user_id) FILTER (
    WHERE
      action = 'cancel_order'
  )) AS users_count
FROM
  user_actions*/
--SELECT * FROM user_actions LIMIT 50
/*SELECT
  COUNT(order_id) AS orders,
  COUNT(order_id) FILTER (
    WHERE
      array_length(product_ids, 1) >= 5
  ) AS large_orders,
  ROUND((COUNT(order_id) FILTER (
    WHERE
      array_length(product_ids, 1) >= 5
  ) / COUNT(order_id)::DECIMAL), 2) AS large_orders_share
FROM
  orders*/
/*SELECT
  sex,
  COUNT (courier_id) AS couriers_count
FROM
  couriers
GROUP BY
  sex
ORDER BY
  couriers_count*/
/*SELECT
  action,
  COUNT(order_id) AS orders_count
FROM
  user_actions
GROUP BY
  action
ORDER BY
  orders_count*/
/*SELECT
  DATE_TRUNC('month', creation_time) AS month,
  COUNT(order_id) AS orders_count
FROM
  orders
GROUP BY
  month
ORDER BY
  month*/
/*SELECT
  DATE_TRUNC('month', time) AS month,
  action,
  COUNT(order_id) AS orders_count
FROM
  user_actions
GROUP BY
  month,
  action
ORDER BY
  month,
  action*/
/*SELECT
  sex,
  MAX(DATE_PART('month', birth_date)) :: INTEGER AS max_month
FROM
  users
GROUP BY
  sex
ORDER BY
  sex*/
/*SELECT
  sex,
  DATE_PART('month', MAX(birth_date)) :: INTEGER AS max_month
FROM
  users
GROUP BY
  sex
ORDER BY
  sex */
/*SELECT
  sex,
  DATE_PART('year', (AGE(current_date,  MIN(birth_date))))::INTEGER AS max_age
FROM
  users
GROUP BY
  sex
ORDER BY
  max_age*/
/*SELECT
  DATE_PART('year', (AGE(current_date, birth_date))) :: INTEGER age,
  COUNT(user_id) AS users_count
FROM
  users
GROUP BY
  age
ORDER BY
  age*/
/*SELECT
  DATE_PART('year', (AGE(current_date, birth_date))) :: INTEGER age,
  sex,
  COUNT(user_id) users_count
FROM
  users
WHERE
  birth_date IS NOT NULL
GROUP BY
  age,
  sex
ORDER BY
  age, sex*/
/*SELECT
  array_length(product_ids, 1) AS order_size,
  COUNT(order_id) orders_count
FROM
  orders
WHERE
  creation_time BETWEEN '2022-08-29'
  AND '2022-09-05'
GROUP BY
  order_size
ORDER BY
  order_size*/
/*SELECT
  array_length(product_ids, 1) AS order_size,
  COUNT(order_id) orders_count
FROM
  orders
WHERE
  TO_CHAR(creation_time, 'Dy') IN ('Mon', 'Tue', 'Wed', 'Thu', 'Fri')
GROUP BY
  order_size
HAVING
  COUNT(order_id) > 2000
ORDER BY
  order_size*/
/*SELECT
  user_id,
  COUNT(DISTINCT order_id) AS created_orders
FROM
  user_actions
WHERE
  time BETWEEN '2022-08-01'
  AND '2022-09-01'
GROUP BY
  user_id,
  action
HAVING
  action = 'create_order'
ORDER BY
  created_orders DESC,
  user_id
LIMIT
  5*/
/*SELECT
  courier_id
FROM
  courier_actions
WHERE
  action = 'deliver_order'
  AND time BETWEEN '2022-09-01' AND '2022-10-01'
GROUP BY
  courier_id
HAVING
  COUNT(courier_id) = 1
ORDER BY
  courier_id*/
/*SELECT
  user_id
FROM
  user_actions
GROUP BY
  user_id,
  action
HAVING
  action = 'create_order' AND
  MAX(time) < '2022-09-08'
ORDER BY
  user_id*/
/*SELECT
  CASE
    WHEN TO_CHAR(creation_time, 'Dy') IN ('Sat', 'Sun') THEN 'weekend'
    ELSE 'weekdays'
    END AS week_part,
    ROUND(AVG(array_length(product_ids, 1)), 2) AS avg_order_size
FROM orders
GROUP BY week_part
ORDER BY avg_order_size*/
/*SELECT
  CASE
    WHEN DATE_PART('year', (AGE(current_date, birth_date))) :: INTEGER < 25 THEN '19-24'
    WHEN DATE_PART('year', (AGE(current_date, birth_date))) :: INTEGER > 24 AND DATE_PART('year', (AGE(current_date, birth_date))) :: INTEGER < 30 THEN '25-29'
    WHEN DATE_PART('year', (AGE(current_date, birth_date))) :: INTEGER > 29 AND DATE_PART('year', (AGE(current_date, birth_date))) :: INTEGER < 36 THEN '30-35'
    WHEN DATE_PART('year', (AGE(current_date, birth_date))) :: INTEGER > 35 AND DATE_PART('year', (AGE(current_date, birth_date))) :: INTEGER < 42 THEN  '36-41'
    END AS group_age,
    COUNT(DISTINCT user_id) AS users_count
FROM users
WHERE birth_date IS NOT NULL
GROUP BY group_age
ORDER BY group_age*/
---------------
Lesson 6 Task --
---------------
SELECT case when date_part('year', age(birth_date)) between 19 and
                 24 then '19-24'
            when date_part('year', age(birth_date)) between 25 and
                 29 then '25-29'
            when date_part('year', age(birth_date)) between 30 and
                 35 then '30-35'
            when date_part('year', age(birth_date)) between 36 and
                 41 then '36-41' end as group_age,
       count(user_id) as users_count
FROM   users
WHERE  birth_date is not null
GROUP BY group_age
ORDER BY group_age
---------------
Lesson 6 Task --
---------------
SELECT
  user_id,
  COUNT(user_id) FILTER (
    WHERE
      action = 'create_order'
  )  AS orders_count,
  ROUND(COUNT(order_id) FILTER (
    WHERE
      action = 'cancel_order'
  )::DECIMAL / COUNT(DISTINCT order_id), 2) AS cancel_rate
FROM
  user_actions
GROUP BY
  user_id
HAVING
  COUNT(user_id) FILTER (
    WHERE
      action = 'create_order'
  ) > 3 AND
  ROUND(COUNT(order_id) FILTER (
    WHERE
      action = 'cancel_order'
  )::DECIMAL / COUNT(DISTINCT order_id), 2) > 0.49
ORDER BY
  user_id
---------------
Lesson 6 Task --
---------------
SELECT
  DATE_PART('isodow', time)::INTEGER AS weekday_number,
  TO_CHAR(time, 'Dy') AS weekday,
  COUNT(order_id) FILTER (
    WHERE
      action = 'create_order'
  )  AS  created_orders,
  COUNT(order_id) FILTER (
    WHERE
      action = 'cancel_order'
  )  AS canceled_orders,
  COUNT(DISTINCT order_id) FILTER (
    WHERE
      action = 'create_order'
  ) - COUNT(order_id) FILTER (
    WHERE
      action = 'cancel_order'
  )  AS actual_orders,
  ROUND((COUNT(order_id) FILTER (WHERE action = 'create_order')
    - COUNT(order_id) FILTER (WHERE action = 'cancel_order')) 
    / COUNT(DISTINCT order_id) FILTER (WHERE action = 'create_order')::DECIMAL, 3) AS success_rate
FROM
  user_actions
WHERE
  time BETWEEN '2022-08-24'
  AND '2022-09-07'
GROUP BY
  weekday_number,
  weekday
ORDER BY
  weekday_number

--SELECT order_id, COUNT(action) as action From user_actions GROUP BY order_id HAVING COUNT(action) > 1
---------------
Lesson 6 Task --
---------------
SELECT  order_id, date_part('year', creation_time) AS year
FROM 	orders
WHERE creation_time >= date_trunc('year', now() - interval '1 year')
GROUP BY order_id, year
---------------
Lesson 7 Task 1
---------------
SELECT
  ROUND(AVG(count_orders), 2) AS orders_avg
FROM
  (
    SELECT COUNT(order_id) AS count_orders
    FROM user_actions
    WHERE action = 'create_order'
    GROUP BY user_id
  ) AS tt_1
---------------
Lesson 7 Task 2
---------------
WITH 
tt_1 AS  (SELECT count(order_id) as count_orders
        FROM   user_actions
        WHERE  action = 'create_order'
        GROUP BY user_id)
SELECT round(avg(count_orders), 2) as orders_avg
FROM tt_1
---------------
Lesson 7 Task 3
---------------
SELECT
  product_id,
  name,
  price
FROM
  products
WHERE
  price > (SELECT MIN(price) FROM products)
ORDER BY
  product_id DESC
---------------
Lesson 7 Task 4
---------------
SELECT
  product_id,
  name,
  price
FROM
  products
WHERE
  price >= (
    SELECT
      AVG(price)
    FROM
      products
  ) + 20
ORDER BY
  product_id DESC
---------------
Lesson 7 Task 5
---------------
SELECT
  COUNT(DISTINCT user_id) AS users_count
FROM
  user_actions
WHERE
  time >= (SELECT MAX(time) FROM user_actions) - INTERVAL '1 week'
  AND action = 'create_order'
---------------
Lesson 7 Task 6
---------------
SELECT
  min(
    age(
      (
        SELECT
          max(time) :: date
        FROM
          courier_actions
      ),
      birth_date
    )
  ) :: varchar as min_age
FROM
  couriers
WHERE
  sex = 'male'
---------------
Lesson 7 Task 7
---------------
/*WITH tt_1 AS(
  SELECT
    order_id
  FROM
    user_actions
  WHERE
    action = 'cancel_order'
)
SELECT
  order_id
FROM
  user_actions
WHERE
  order_id NOT IN (
    SELECT
      *
    FROM
      tt_1
  )
ORDER BY
  order_id
LIMIT
  1000 */
SELECT order_id
FROM   user_actions
WHERE  order_id not in (SELECT order_id
                        FROM   user_actions
                        WHERE  action = 'cancel_order')
ORDER BY order_id limit 1000
---------------
Lesson 7 Task 8
---------------
/*WITH tcount AS(
  SELECT
    COUNT(DISTINCT order_id) AS orders_count,
    user_id
  FROM
    user_actions
  WHERE
    action = 'create_order'
  GROUP BY
    user_id
),
  tavg AS(
  SELECT
    ROUND(SUM(orders_count) / COUNT(DISTINCT user_id), 2) AS orders_avg
  FROM
    tcount   
  )
SELECT
  user_id,
  orders_count,
  orders_avg,
  orders_count - orders_avg AS orders_diff
FROM
  tcount, tavg
ORDER BY
  user_id
LIMIT
  1000*/
WITH t1 as (
  SELECT
    user_id,
    count(order_id) as orders_count
  FROM
    user_actions
  WHERE
    action = 'create_order'
  GROUP BY
    user_id
)
SELECT
  user_id,
  orders_count,
  round(
    (
      SELECT
        avg(orders_count)
      FROM
        t1
    ),
    2
  ) as orders_avg,
  orders_count - round(
    (
      SELECT
        avg(orders_count)
      FROM
        t1
    ),
    2
  ) as orders_diff
FROM
  t1
ORDER BY
  user_id
limit
  1000
---------------
Lesson 7 Task 9
---------------
WITH tavg AS (
  SELECT
    ROUND(AVG(price), 2) AS avgprice
  FROM
    products
)
SELECT
  product_id,
  name,
  price,
  CASE
    WHEN price - avgprice >= 50 THEN price * 0.85
    WHEN avgprice - price >= 50 THEN price * 0.9
    ELSE price
  END AS new_price
FROM
  products,
  tavg
ORDER BY
  price DESC,
  product_id
---------------
Lesson 7 Task 10
---------------
SELECT
  COUNT(order_id) AS orders_count
FROM
  courier_actions
WHERE
  action = 'accept_order'
  AND order_id not in (
    SELECT
      order_id
    FROM
      user_actions
    WHERE
      action = 'create_order'
  )
SELECT count(distinct order_id) as orders_count
FROM   courier_actions
WHERE  order_id not in (SELECT order_id
                        FROM   user_actions) 
---------------
Lesson 7 Task 11
---------------
/*SELECT count(distinct order_id) as orders_count
FROM   courier_actions
WHERE  order_id not in (SELECT order_id
                        FROM   user_actions)*/
/*SELECT
  (SELECT COUNT(order_id) FROM courier_actions WHERE action = 'accept_order') - (SELECT COUNT(order_id) FROM courier_actions  WHERE action = 'deliver_order') AS orders_count
FROM
  courier_actions
GROUP BY orders_count  */
--SELECT * FROM courier_actions    LIMIT 100   
SELECT count(order_id) as orders_count
FROM   courier_actions
WHERE  order_id not in (SELECT order_id
                        FROM   courier_actions
                        WHERE  action = 'deliver_order')
---------------
Lesson 7 Task 12
---------------
SELECT
  COUNT(order_id) FILTER (
    WHERE
      action = 'accept_order'
  ) AS orders_canceled,
  COUNT(order_id) FILTER (
    WHERE
      action = 'deliver_order'
  ) AS orders_canceled_and_delivered
FROM
  courier_actions
WHERE
  order_id IN (
    SELECT
      order_id
    FROM
      user_actions
    WHERE
      action = 'cancel_order'
  )
---------------
Lesson 7 Task 13
---------------
WITH 
tcancel AS(
  SELECT order_id FROM user_actions WHERE action = 'cancel_order'
),
tdeliver AS(
  SELECT order_id FROM courier_actions WHERE action = 'deliver_order'
)
SELECT
  COUNT(DISTINCT order_id) FILTER(WHERE order_id IN (SELECT * FROM tcancel)) AS orders_canceled,
  COUNT(order_id) FILTER(WHERE order_id NOT IN (SELECT * FROM tcancel) AND order_id NOT IN (SELECT * FROM tdeliver)) AS orders_in_process,
  COUNT(DISTINCT order_id) FILTER(WHERE order_id IN (SELECT * FROM tcancel) AND order_id NOT IN (SELECT * FROM tdeliver)) AS orders_undelivered
FROM
  courier_actions

SELECT count(distinct order_id) as orders_undelivered,
       count(order_id) filter (WHERE action = 'cancel_order') as orders_canceled,
       count(distinct order_id) - count(order_id) filter (WHERE action = 'cancel_order') as orders_in_process
FROM   user_actions
WHERE  order_id in (SELECT order_id
                    FROM   courier_actions
                    WHERE  order_id not in (SELECT order_id
                                            FROM   courier_actions
                                            WHERE  action = 'deliver_order'))  
---------------
Lesson 7 Task 14
---------------
SELECT
  user_id,
  birth_date
FROM
  users
WHERE
  birth_date < (SELECT MIN(birth_date) FROM users WHERE sex = 'female') 
ORDER BY
  user_id
---------------
Lesson 7 Task 15
---------------
SELECT
  order_id,
  product_ids
FROM
  orders
WHERE
  order_id IN (SELECT order_id FROM courier_actions WHERE action = 'deliver_order' ORDER BY time DESC LIMIT 100)
ORDER BY
  order_id
---------------
Lesson 7 Task 16
---------------
SELECT
  courier_id,
  birth_date,
  sex
FROM
  couriers
WHERE
  courier_id IN (
     SELECT
    courier_id
  FROM
    courier_actions
  WHERE
    action = 'deliver_order'
    AND time BETWEEN '2022-09-01'
    AND '2022-09-30'
  GROUP BY
    courier_id
  HAVING
    COUNT(DISTINCT order_id) > 29
  )
ORDER BY
  courier_id

SELECT courier_id,
       birth_date,
       sex
FROM   couriers
WHERE  courier_id in (SELECT courier_id
                      FROM   courier_actions
                      WHERE  date_part('month', time) = 9
                         and date_part('year', time) = 2022
                         and action = 'deliver_order'
                      GROUP BY courier_id having count(distinct order_id) >= 30)
ORDER BY courier_id
---------------
Lesson 7 Task 17
---------------

---------------
Lesson 7 Task 18
---------------

---------------
Lesson 7 Task 19
---------------

---------------
Lesson 7 Task 20
---------------

---------------
Lesson 7 Task 21
---------------

---------------
Lesson 7 Task 22
---------------

---------------
Lesson 7 Task 23
---------------


courier_actions: action - 'accept_order' 'deliver_order'
user_actions: action - 'create_order' 'cancel_order'

####^ CODE ^#######^ CODE ^#######^ CODE ^#######^ CODE ^#######^ CODE ^#######^ CODE ^####
####^ CODE ^#######^ CODE ^#######^ CODE ^#######^ CODE ^#######^ CODE ^#######^ CODE ^####
####^ CODE ^#######^ CODE ^#######^ CODE ^#######^ CODE ^#######^ CODE ^#######^ CODE ^####

Правильный порядок операторов в запросе выглядит так:

SELECT -- перечисление полей результирующей таблицы
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей

Сейчас важно запомнить порядок записи всех известных нам ключевых слов:

    SELECT
    FROM
    ORDER BY
    LIMIT

Также важно понять, что порядок их выполнения несколько отличается от того, в какой последовательности они указываются в SQL-запросе:

    Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
    Затем SELECT — отбираются указанные столбцы.
    Потом ORDER BY — производится сортировка результирующей таблицы.
    И в самом конце LIMIT — ограничивается количество выводимых записей.

На вход функции CAST необходимо подать имя колонки, указав через AS тип данных, к которому нужно привести все значения:
SELECT CAST(column AS VARCHAR)
FROM table
Также изменить тип данных можно с помощью специального синтаксиса с двумя двоеточиями («::»):
SELECT column::VARCHAR
FROM table

Функция CONCAT принимает на вход несколько аргументов и возвращает результат их последовательного сложения друг с другом. Хорошая аналогия — составление предложений из разных карточек со словами:
SELECT CONCAT('SQL', ' ', 'Simulator ', 2022)

Результат:
SQL Simulator 2022

На практике часто встречаются задачи, когда нужна, например, не вся дата, а какая-то её часть: год, месяц, день, час и т.д. Извлечь эту часть из исходных данных позволяет функция DATE_PART. Её синтаксис следующий:
SELECT DATE_PART(part, column)
На месте part необходимо в кавычках указать ту часть, которую нужно извлечь: 'year', 'month', 'day', 'hour' и т.д. На месте column следует указать нужную колонку либо конкретную дату или время.

Работу COALESCE можно описать следующим образом: она буквально читает список значений слева направо и, как только видит значение, которое не является NULL, сразу же возвращает его и прекращает чтение списка. Посмотрите внимательно на следующие примеры:
SELECT COALESCE(NULL, 'I am not NULL' , 'karpov.courses')
Результат:
I am not NULL

SELECT COALESCE(NULL, 25, 100, 150)
Результат:
25

SELECT COALESCE('NULL', 'I am not NULL', 'karpov.courses')
Результат:
NULL

Одним из аргументов функции COALESCE может выступать результат выполнения другой функции:
SELECT COALESCE(NULL, LOWER('I am not NULL'), 'karpov.courses')

Результат:
i am not null

Чтобы заполнить пропуски в колонке, достаточно применить функцию COALESCE к колонке с пропусками и указать в качестве второго аргумента то значение, которое мы хотим видеть вместо NULL:
SELECT COALESCE(column, 'filler value')
FROM table

Функция COALESCE применится к каждому значению в колонке. Если это значение окажется NULL, она заменит его на значение, указанное вторым аргументом. Если значение в колонке, наоборот, окажется не NULL, то функция просто вернёт это значение.
При этом к колонке с пропусками можно также заранее применять разные другие функции:
SELECT COALESCE(LEFT(column, 5), 'filler value')
FROM table

Наряду с арифметическими операторами в PostgreSQL также доступны разные математические функции. Например, для округления вещественных чисел («чисел с плавающей точкой») можно использовать ROUND:
SELECT ROUND(100.5454, 2)
Результат:
100.55

SELECT ROUND(100.551, 1)
Результат:
100.6

SELECT ROUND(100.5511)
Результат:
101.0

Следующая конструкция разобъёт весь список наименований на три категории: «мясо», «рыба» и «другое». Соответственно, если в первых двух условиях мы не учтём какие-то наименования из колонки name (например, «телятину»), то они попадут в категорию «другое».
SELECT name,
       CASE 
       WHEN name='свинина' OR name='баранина' OR name='курица' THEN 'мясо'
       WHEN name='треска' OR name='форель' OR name='окунь' THEN 'рыба'
       ELSE 'другое'
       END AS сategory
FROM table

Результатом этих логических операций также могут быть три вышеуказанных логических состояния (TRUE, FALSE или NULL):
a	b	a AND b	a OR b
TRUE	TRUE	TRUE	TRUE
TRUE	FALSE	FALSE	TRUE
TRUE	NULL	NULL	TRUE
FALSE	FALSE	FALSE	FALSE
FALSE	NULL	FALSE	NULL
NULL	NULL	NULL	NULL
a	NOT a
TRUE	FALSE
FALSE	TRUE
NULL	NULL

существуют приоритеты выполнения операций:
1. умножение и деление (* и /)
2. сложение и вычитание (+ и -)
3. операторы сравнения (=, !=, >, <, >=, <=)
4. NOT
5. AND
6. OR

В SQL для фильтрации данных используется оператор WHERE. После оператора WHERE указывается логическое выражение, результат которого определяет, будет ли строка включена в результирующую таблицу. Если условие оказывается истинным (TRUE), то строка включается в результат, если ложным (FALSE) — строка исключается.

Таким образом, каждая строка в таблице проходит проверку на соответствие определённому условию, и в результате этих проверок формируется таблица, над которой затем проводятся операции, указанные в блоке SELECT.

Оператор WHERE и логическое выражение указываются после блока FROM:
SELECT column_1, column_2
FROM table
WHERE column_2 >= 0

В свою очередь операторы ORDER BY и LIMIT записываются уже после оператора WHERE. Если добавить их в пример выше, то запрос будет выглядеть так:
SELECT column_1, column_2
FROM table
WHERE column_2 >= 0
ORDER BY column_1
LIMIT 100
В результате мы сначала отфильтруем необходимые нам строки, затем выберем столбцы, отмеченные в SELECT, а потом отсортируем результирующую таблицу, ограничив число выводимых записей.

Таким образом, порядок записи известных нам на текущий момент ключевых слов выглядит так:

    SELECT
    FROM
    WHERE
    ORDER BY
    LIMIT

Снова обратим внимание, что порядок их выполнения отличается от того, в какой последовательности они указываются в запросе:

    Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
    Далее WHERE — отфильтровываются строки, соответствующие условию.
    Затем SELECT — отбираются указанные столбцы и применяются функции.
    Потом ORDER BY — производится сортировка результирующей таблицы.
    И в самом конце LIMIT — ограничивается количество выводимых записей.

Иными словами, в результате выполнения запроса сначала происходит подготовка таблицы к работе, а уже затем над ней выполняются разные операции.

После оператора WHERE к колонкам можно также применять разные функции:
SELECT column_1, column_2
FROM table 
WHERE LOWER(column_1) = 'karpov.courses'

В примере выше каждое значение в колонке column_1 сначала будет приведено к нижнему регистру, а затем сопоставлено со значением 'karpov.courses'. При этом в результат будут включены исходные значения в колонке column_1. Таким образом, функция послужит только для фильтрации записей, но на сами значения в колонках никак не повлияет.

Обратите внимание, что использовать алиасы, присвоенные колонкам в операторе SELECT, всё так же нельзя. Следующий запрос вернёт ошибку:
-- Этот запрос вернёт ошибку:

SELECT column_1 AS new_column_1, column_2
FROM table 
WHERE LOWER(new_column_1) = 'karpov.courses'

 Для фильтрации по колонкам с текстовыми значениями в SQL предусмотрен оператор LIKE.

Оператор LIKE не просто сравнивает строки на полное совпадение (или несовпадение), а проверяет их на соответствие заданному шаблону: если строка ему соответствует, то возвращается TRUE, в противном случае — FALSE. Как можно догадаться, конструкция NOT LIKE работает с точностью до наоборот.

Шаблоны могут содержать как обычные символы, так и символы-шаблоны: знак процента ( % ) и подчёркивание ( _ ). Подчёркивание подменяет любой одиночный символ, а знак процента — любую (в том числе и пустую) последовательность символов:
SELECT 'karpov.courses' LIKE 'karpov%'
Результат:
true

SELECT 'karpov.courses' LIKE 'karpov_'
Результат:
false

SELECT 'karpov.courses' LIKE '%karpov%'
Результат:
true

SELECT 'karpov.courses' LIKE '_karpov%'
Результат:
false

SELECT 'karpov.courses' LIKE '%.%'
Результат:
true

SELECT 'karpov.courses' LIKE '_._'
Результат:
false

SELECT 'karpov.courses' LIKE 'Karpov%'
Результат:
false

Оператор IN проверяет, соответствует ли значение в колонке одному из значений из заданного списка. Иными словами, он проверяет, входит ли значение в этот список:
SELECT column_1, column_2
FROM table
WHERE column_1 IN ('product_1', 'product_2', 'product_3')

В свою очередь оператор BETWEEN позволяет отобрать данные, относящиеся к некоторому интервалу. При этом границы интервала включаются:
SELECT column_1, column_2
FROM table
WHERE column_2 BETWEEN 5 AND 10

Оператор BETWEEN можно использовать и для фильтрации по колонкам с датами и временем
SELECT column_1, column_2, column_3
FROM table
WHERE column_3 BETWEEN '2022-11-20' AND '2022-12-31'

Для получения обратного результата в сочетании с операторами IN и BETWEEN можно использовать оператор NOT:
SELECT column_1, column_2
FROM table
WHERE column_1 NOT IN ('product_1', 'product_2', 'product_3')


SELECT column_1, column_2
FROM table
WHERE column_2 NOT BETWEEN 5 AND 10

Для проверки на NULL значения в SQL есть оператор IS NULL. В сочетании с WHERE записывается он так:
SELECT column_1, column_2
FROM table
WHERE column_1 IS NULL

Если же, наоборот, необходимо отобрать не NULL значения, то дополнительно используется оператор NOT:
SELECT column_1, column_2
FROM table
WHERE column_1 IS NOT NULL

Ключевое слово DISTINCT позволяет отбирать уникальные записи, т.е. избавляться от всех дубликатов в таблице.

Указывается DISTINCT сразу после SELECT. Для вывода уникальных значений в одной колонке можно составить следующий запрос:
SELECT DISTINCT column
FROM table

запрос для двух колонок будет выглядеть так:
SELECT DISTINCT column_1, column_2
FROM table
В таком случае в качестве результата запрос вернёт уникальные комбинации значений в колонках. 

Агрегирующими функциями называют функции, которые обрабатывают определённый набор строк и возвращают одно обобщающее значение. Если вы когда-нибудь работали в Excel, то наверняка сталкивались с подсчётом суммы или максимального/минимального значения по столбцу — речь идёт именно об этом.

Вот несколько примеров таких функций в SQL:

    COUNT — считает количество значений в колонке.
    SUM — вычисляет сумму значений.
    AVG — вычисляет среднее значение.
    MAX — вычисляет максимальное значение.
    MIN — вычисляет минимальное значение.
Пример:
SELECT COUNT(column) AS count
FROM table


SELECT SUM(column_1) AS sum,
       AVG(column_2) AS average
FROM table

важно учитывать один нюанс: запрос со звёздочкой возвращает количество вообще всех записей в таблице, а запрос с указанием столбца — количество тех записей, где в заданном столбце значения не являются NULL.

Таким образом, если в некоторой колонке column есть пропуски, выражения COUNT(*) и COUNT(column) вернут разные значения.

агрегирующие функции можно применять в сочетании с ключевым словом DISTINCT. В таком случае расчёты будут производиться только по уникальным значениям.

Если в случае с MIN и MAX это не имеет особого смысла, то при расчёте AVG, SUM и COUNT иногда это бывает полезно:
SELECT SUM(DISTINCT column) AS sum_distinct
FROM table

При этом довольно часто DISTINCT используется именно в сочетании с COUNT — для подсчёта числа уникальных пользователей, уникальных заказов и т.д.
SELECT COUNT(DISTINCT column) AS count_distinct
FROM table

Функция array_length вычисляет количество элементов в массиве (длину массива) и записывается следующим образом:
SELECT array_length(ARRAY[1,2,3], 1)
Результат:
3
Единица в качестве второго аргумента — это размерность массива, по которой считается его длина. Так как список у нас одноразмерный (просто значения, записанные в одну строчку), то выбор у нас невелик — можем указать только первую размерность.
Если бы у нас была таблица N x N, в которой были бы и строки, и столбцы, то размерности было бы две: первая соответствовала бы количеству строк, а вторая — числу столбцов. В таком случае мы могли бы указать либо первую, либо вторую размерность.
 _______
| 1 | 2 |
| 3 | 4 |
| 5 | 6 |
 ‾‾‾‾‾‾‾
В этой таблице 3 строки и 2 столбца, поэтому её можно описать в виде следующего списка из трёх вложенных в него списков:
ARRAY[[1,2], [3,4], [5,6]]
В примере выше количество списков внутри основного списка — это количество строк в таблице, а количество элементов внутри каждого внутреннего списка — это количество столбцов.

Обратите внимание на результат вычислений функции array_length для первой и второй размерностей:
SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 1)
Результат:
3

SELECT array_length(ARRAY[[1,2], [3,4], [5,6]], 2)
Результат:
2

В качестве аргумента агрегирующих функций могут выступать не только столбцы, но также расчётные колонки или результат другой функции:
SELECT AVG(some_function(column))
FROM table
SELECT AVG(column_1 + column_2)
FROM table

Функция AGE возвращает разницу между двумя значениями, представленными в формате TIMESTAMP. При этом из первого значения вычитается второе, а сама разница получается в формате INTERVAL:
SELECT AGE('2022-12-12', '2021-11-10')
Результат:
397 days, 0:00:00

Если в качестве первого аргумента не указать ничего, то на место первой даты автоматически подставится текущая дата (полночь текущего дня, т.е. начало дня). 
текущей дате соответствует значение current_date, которое можно указывать в качестве аргумента функции AGE: 
SELECT AGE(current_date, '2021-11-10')
Результат:
397 days, 0:00:00

чтобы результат отображался не в виде количества дней, а в более удобном формате, можно переводить результат вычислений в тип VARCHAR:
SELECT AGE(current_date, '2021-11-10')::VARCHAR
Результат:
1 year 1 mon 2 days

Аргументом агрегирующей функции может быть и более сложная расчётная колонка — например, полученная в результате работы конструкции CASE.
В таком случае сама конструкция CASE помещается внутрь скобок агрегирующей функции:
AVG(
    CASE  
    WHEN logical_expression_1 THEN expression_1
    WHEN logical_expression_2 THEN expression_2
    ELSE expression_else
    END
)
Так, если бы в нашей таблице все товары были разбиты по категориям и мы захотели бы посчитать среднюю цену товаров с учётом повышающих или понижающих коэффициентов для каждой категории, то мы могли бы сделать это, например, следующим образом:
SELECT AVG(
    CASE 
    WHEN category='мясо' THEN price*0.95
    WHEN category='рыба' THEN price*0.9
    WHEN category='напитки' THEN price*1.05
    ELSE price
    END
    ) AS avg_price
FROM products

Результаты нескольких агрегирующих функций можно использовать в одном запросе для проведения над ними арифметических операций:
SELECT (SUM(column_1) + SUM(column_2)) / 2
FROM table

познакомимся с более продвинутым функционалом — агрегатными выражениями с фильтрацией.
Если после агрегирующей функции указать ключевое слово FILTER и поместить в скобках некоторое условие condition после WHERE, то агрегирующей функции на вход будут поданы только те строки, для которых условие фильтра окажется истинным.
В общем виде эта конструкция выглядит так:
SELECT agg_function(column) FILTER (WHERE condition)
FROM table
Например, если бы мы захотели посчитать среднюю цену только для товаров категории 'рыба', то запрос выглядел бы так:
SELECT AVG(price) FILTER (WHERE category = 'рыба') AS avg_fish_price
FROM table

Обратите внимание: это очень похоже на обычную фильтрацию с агрегацией, которую мы рассматривали в предыдущих задачах, только в данном случае условие на отбор записей указывается сразу в блоке SELECT.
Преимущество такой записи в том, что она позволяет проводить расчёты без промежуточных запросов с условиями в блоке WHERE.

1.Сначала в таблице определяются строки, в которых в указанном в GROUP BY столбце есть одинаковые значения.
2.Далее по этим значениям записи объединяются в группы, причём в группе может быть даже одна запись.
3.После этого с помощью агрегирующих функций над элементами этих групп, как правило, проводятся определённые операции. Например, с помощью SUM вычисляется сумма значений в каком-либо столбце в каждой группе:
SELECT column_1, SUM(column_2) AS sum
FROM table
GROUP BY column_1
4. Затем в результирующий запрос попадает по одной уникальной записи из столбца, по которому осуществлялась группировка. При этом напротив каждого такого значения отражается результат агрегации по соответствующей группе, если агрегация проводилась.
А теперь сделаем несколько важных уточнений.
— Во-первых, группировку можно делать сразу по нескольким колонкам:
SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1, column_2
В таком случае количество групп в результирующей таблице будет равно числу уникальных комбинаций значений в нескольких столбцах, указанных в GROUP BY. При этом для каждой такой группы будет проведена агрегация значений по колонке, указанной в качества аргумента агрегирующей функции.

— Во-вторых, к группам, образовавшимся в результате GROUP BY, можно применять сразу несколько агрегирующих функций (в том числе к разным колонкам):

SELECT column_1, SUM(column_2) AS sum, AVG(column_3) AS avg
FROM table
GROUP BY column_1

При этом агрегирующую функцию можно применить к той же самой колонке, по которой осуществляется группировка:

SELECT column_1, COUNT(column_1) AS count
FROM table
GROUP BY column_1

Не всегда такая операция имеет смысл, но она допустима. Например, с помощью функции COUNT можно посчитать количество записей, попавших в каждую группу.

— В-третьих, после группировки к результатам агрегирующих функций можно применять другие функции. Также над ними можно сразу проводить арифметические операции:

SELECT column_1, ROUND(SUM(column_2), 2) AS rounded_sum
FROM table
GROUP BY column_1


SELECT column_1, SUM(column_2)::DECIMAL / SUM(column_3) * 100 AS share
FROM table
GROUP BY column_1

— В-четвёртых, агрегацию не обязательно проводить по уже имеющимся колонкам — можно сначала применить некоторую функцию в колонке из исходной таблицы, а затем сразу провести агрегацию по новой колонке:

SELECT column_1, SUM(some_function(column_2)) AS sum_over_function
FROM table
GROUP BY column_1

— В-пятых, группировку можно делать сразу по новым полям, посчитанным в SELECT. При этом допускается использование в GROUP BY алиаса колонки, указанного в SELECT.

Например, если нам необходимо сгруппировать данные по дням, выделив дату из какой-то колонки, и посчитать сумму некоторых значений в каждый из дней, то можно использовать следующие запросы, которые дадут одинаковый результат:

SELECT DATE(column_1) AS date, SUM(column_2) AS sum
FROM table
GROUP BY DATE(column_1)


SELECT DATE(column_1) AS date, SUM(column_2) AS sum
FROM table
GROUP BY date

Важно: несмотря на то, что в соответствии с порядком выполнения операторов блок SELECT выполняется после блока GROUP BY, в данном случае PostgreSQL позволяет нам немного отойти от правил и упростить процесс написания запроса. Однако такой «синтаксический сахар» есть не в каждой СУБД, поэтому при работе с другими инструментами будьте аккуратны — в общем случае рекомендуется дублировать расчётное поле в блоке GROUP BY и не использовать в нём алиасы колонок из SELECT.

— В-шестых, делать агрегацию после группировки не обязательно. Если не указать агрегирующую функцию, то запрос вернёт уникальные значения в столбце (или уникальные комбинации значений в столбцах), т.е. тот же результат, что и оператор DISTINCT. Можете самостоятельно запустить следующие запросы в Redash и убедиться:

SELECT user_id
FROM user_actions
GROUP BY user_id


SELECT DISTINCT user_id
FROM user_actions

Кстати, вопрос о том, какими способами можно отобрать уникальные значения в столбце, часто встречается на собеседованиях.

— В-седьмых, при использовании группировки колонки, указанные в SELECT, должны находиться и в GROUP BY, если они не используются в агрегирующих функциях.

Это обязательное условие, и если оно не будет выполнено, то база данных вернёт ошибку.

Следующий запрос работать не будет, так как в GROUP BY указаны не все неагрегированные колонки из блока SELECT: 

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1

То есть в запросе выше мы сгруппировали данные по колонке column_1, но при этом попросили базу данных вывести группировку по колонкам column_1 и column_2 с расчётом суммы некоторых значений в колонке column_3. Так делать нельзя.

В данном случае правильным был бы следующий запрос:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1, column_2

Обратите внимание, что в обратную сторону указанное выше правило не работает: если мы что-то указали в GROUP BY, то это совсем не обязательно указывать в SELECT. Иными словами, можно не выводить наименования колонок, по которым осуществляется группировка.

Например, в этом запросе в блоке SELECT нет колонки, указанной в GROUP BY. Тем не менее такой запрос всё равно сработает:

SELECT SUM(column_2) AS sum
FROM table
GROUP BY column_1

Дело в том, что сама группировка всегда происходит до выполнения блока SELECT, где мы по сути указываем, что включить в результат. То есть даже если мы не укажем колонку в SELECT, но укажем её в GROUP BY, группы всё равно будут сформированы, но их наименования просто не будут включены в результирующую таблицу.

— И наконец, группировка всегда выполняется после фильтрации, т.е. сначала выполняются инструкции в WHERE и только потом данные группируются с помощью GROUP BY:

SELECT column_1, SUM(column_2) AS sum
FROM table
WHERE column_3 > 0
GROUP BY column_1

Таким образом, порядок записи ключевых слов выглядит так:

    SELECT
    FROM
    WHERE
    GROUP BY
    ORDER BY
    LIMIT

В то же время порядок выполнения операторов в запросе следующий:

    Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
    Далее WHERE — отфильтровываются строки, соответствующие условию.
    Потом GROUP BY — строки объединяются в группы и производится агрегация.
    Затем SELECT — отбираются указанные столбцы.
    Потом ORDER BY — производится сортировка результирующей таблицы.
    И в самом конце LIMIT — ограничивается количество выводимых записей.

И ещё: вместо названий колонок в блоке GROUP BY можно использовать порядковые номера колонок, указанных в SELECT. Например, следующие запросы эквивалентны:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1, column_2


SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY 1, 2

При этом номера колонок из SELECT можно также использовать при сортировке в операторе ORDER BY:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY 1, 2
ORDER BY 3

Посчитаем, сколько заказов было сделано в каждом месяце. Разумеется, для этого нам потребуется как-то получить месяц из каждой даты. Это можно было бы сделать с помощью функции DATE_PART, но в этот раз для работы с датами мы попробуем новую функцию DATE_TRUNC.

Функция DATE_TRUNC используется для усечения дат и времени, т.е. она работает аналогично округлению ROUND, только для типов данных TIMESTAMP и INTERVAL.
Синтаксис у неё такой же, как и у DATE_PART:
SELECT DATE_TRUNC(part, column)
На месте part в кавычках указывается, до какой точности следует округлять переданное значение времени:  'year', 'month', 'day', 'hour' и т.д.
Возвращаемое значение имеет тип TIMESTAMP или INTERVAL, а все «части» исходного значения, менее значимые, чем заданная «часть», приравниваются к нулю (или единице, если это номер дня или месяца):
SELECT DATE_TRUNC('month', TIMESTAMP '2022-01-12 08:55:30')
Результат:
01/01/22 00:00

SELECT DATE_TRUNC('day', TIMESTAMP '2022-01-12 08:55:30')
Результат:
12/01/22 00:00	

SELECT DATE_TRUNC('hour', TIMESTAMP '2022-01-12 08:55:30')
Результат:
12/01/22 08:00	

Агрегацию не обязательно проводить по уже имеющимся колонкам — колонки можно «создавать» в рамках того же запроса, в котором происходит группировка:
SELECT column_1, MIN(DATE_TRUNC('month', column_2)) AS min_month
FROM table
GROUP BY column_1

В примере выше с помощью функции DATE_TRUNC мы сначала привели все даты в колонке column_2 к началу месяца (получив по сути новую колонку), а затем сразу же провели агрегацию по новой колонке, посчитав минимальную округлённую дату в каждой группе, сформированной на основе колонки column_1.

Обратите внимание, что тот же самый результат мы могли бы получить и с помощью такого запроса:
SELECT column_1, DATE_TRUNC('month', MIN(column_2)) AS min_month
FROM table
GROUP BY column_1

Часто результат зависит от того, в каком порядке применяются обычные и агрегирующие функции. Например, следующие два запроса дадут разный результат:
SELECT column_1, MIN(DATE_PART('month', column_2)) AS min_month
FROM table
GROUP BY column_1


SELECT column_1, DATE_PART('month', MIN(column_2)) AS min_month
FROM table
GROUP BY column_1

Но что если в результат группировки и агрегации мы хотим включить не все группы, а только те, для которых выполняется некоторое условие? Например, только те размеры заказов, количество которых выше или ниже определённого значения? Или только те возрастные группы, количество пользователей в которых превышает заданный порог?

Судя по всему, для этого нам необходимо каким-то образом наложить фильтрацию уже поверх группировки. Но, как мы выяснили, оператор WHERE использовать после GROUP BY нельзя. Что же тогда делать?

Специально для таких случаев существует оператор HAVING, который тоже выполняет функцию фильтрации, но работает поверх уже сгруппированных данных.

В этом и заключается ключевое отличие операторов WHERE и HAVING: первый фильтрует записи в таблице перед группировкой и агрегацией, а второй — после. Кстати, это простой, но довольно популярный вопрос на собеседовании по SQL.

Ещё одна важная особенность работы оператора HAVING: в этом блоке нельзя указывать алиасы полей с результатом агрегации из блока SELECT. Дело в том, что в соответствии с порядком выполнения запроса оператор SELECT выполняется после оператора HAVING. Поэтому агрегацию необходимо также указывать и в HAVING.

Например, такой запрос не сработает:
SELECT column_1, SUM(column_2) AS new_column
FROM table
GROUP BY column_1
HAVING new_column = 100

А такой сработает:
SELECT column_1, SUM(column_2) AS new_column
FROM table
GROUP BY column_1
HAVING SUM(column_2) = 100

Кроме того, в HAVING не обязательно указывать ту же агрегацию, что и в блоке SELECT, равно как и в SELECT не обязательно указывать агрегацию из HAVING:
SELECT column_1, SUM(column_2) AS new_column
FROM table
GROUP BY column_1
HAVING AVG(column_3) < 50

список ключевых слов в запросе:

SELECT
FROM
WHERE
GROUP BY
HAVING
ORDER BY
LIMIT
Порядок их выполнения в запросе следующий:

Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
Далее WHERE — отфильтровываются строки, соответствующие условию.
Потом GROUP BY — строки объединяются в группы и производится агрегация.
Затем HAVING — отфильтровываются группы, соответствующие условию.
После этого SELECT — отбираются указанные столбцы.
Потом ORDER BY — производится сортировка результирующей таблицы.
И в самом конце LIMIT — ограничивается количество выводимых записей.

Для получения наименования дня недели из колонки с датой или отметкой времени можно использовать, например, функцию DATE_PART с параметром 'isodow' либо функцию TO_CHAR с параметром 'Dy':

SELECT TO_CHAR(TIMESTAMP '2022-08-29', 'Dy')
Результат:
Mon

В качестве поля для группировки может выступать и более сложная расчётная колонка — например, результат выполнения условной конструкции CASE:
SELECT 
       CASE 
       WHEN name='свинина' OR name='баранина' OR name='курица' THEN 'мясо'
       WHEN name='треска' OR name='форель' OR name='окунь' THEN 'рыба'
       ELSE 'другое'
       END AS сategory,
       AVG(price) AS average_price
FROM table
GROUP BY сategory

конструкцию можно применять не только ко всей таблице, но и отдельно к каждой группе, сформированной с помощью GROUP BY. В общем виде она будет выглядеть так:
SELECT column_1, agg_function(column_2) FILTER (WHERE condition)
FROM table
GROUP BY column_1

Например, если бы мы захотели посчитать среднюю цену по категориям товаров и учесть только те продукты, которые ещё остались на складе, то запрос выглядел бы так:
SELECT category, AVG(price) FILTER (WHERE product_count > 0) AS avg_price
FROM table
GROUP BY category

В этом уроке мы:

    Научились группировать данные и узнали разные нюансы работы оператора GROUP BY.
    Поработали с агрегирующими функциями и научились применять их к сгруппированным данным.
    Узнали, что к результату группировки можно применять фильтрацию с помощью оператора HAVING.
    Ещё немного поработали с датами и познакомились с новыми функциями DATE_TRUNC и TO_CHAR.
    Решили несколько задач на CASE с группировкой.
    Научились применять FILTER и агрегатные выражения с фильтрацией поверх группировки
Известные нам на текущий момент ключевые слова и порядок их написания в запросе:
SELECT     -- перечисление полей результирующей таблицы
FROM       -- указание источника данных
WHERE      -- фильтрация данных
GROUP BY   -- группировка данных
HAVING     -- фильтрация данных после группировки
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей

К текущему уроку мы уже успели познакомиться с основными операторами, которые составляют «скелет» стандартного SQL-запроса: SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY и LIMIT.

Мы уже знаем, что порядок их указания в запросе следующий:
SELECT     -- перечисление полей результирующей таблицы
FROM       -- указание источника данных
WHERE      -- фильтрация данных
GROUP BY   -- группировка данных
HAVING     -- фильтрация данных после группировки
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей

Тем не менее важно помнить, что порядок выполнения операторов в СУБД несколько отличается от порядка их написания в запросе. В упрощённом виде порядок выполнения запроса в PostgreSQL такой:
FROM       -- указание источника данных
WHERE      -- фильтрация данных
GROUP BY   -- группировка данных
HAVING     -- фильтрация данных после группировки
SELECT     -- перечисление полей результирующей таблицы
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей

Таким образом:

    Сначала с помощью FROM определяется таблица.
    Затем в соответствии с указанным в WHERE условием из этой таблицы отбираются записи.
    Потом выбранные данные группируются и агрегируются с помощью GROUP BY.
    Далее из агрегированных записей отбираются те, которые удовлетворяют условию в HAVING.
    Только после этого в соответствии с указанными в SELECT инструкциями формируется результирующая таблица — отбираются нужные колонки, расчётным полям присваиваются новые имена и т.д.
    Затем результирующая таблица сортируется в соответствии с правилами в ORDER BY.
    И наконец срабатывает ограничение на количество строк, указанное в LIMIT.

к результату выполнения подзапроса можно обращаться так же, как и к таблицам в базе данных, т.е. использовать их в блоке FROM вместо имеющихся таблиц:
SELECT column_1
FROM (
    SELECT column_1, column_2
    FROM table
) AS subquery_1
По сути подзапрос — это такая же таблица, только временная. Она формируется в процессе выполнения основного запроса и нигде не сохраняется.
Важный момент: при использовании подзапроса в блоке FROM сформированной в подзапросе таблице необходимо присвоить какой-нибудь алиас, иначе основной запрос не сработает. В примере выше мы обозначили результат подзапроса как subquery_1.

SELECT sex, COUNT(user_id) AS users_count
FROM users
WHERE sex = 'male'
GROUP BY sex

SELECT sex, COUNT(user_id) AS users_count
FROM users
GROUP BY sex
HAVING sex = 'male'

Но то же самое можно сделать и с помощью подзапроса:
SELECT sex, users_count
FROM (
    SELECT sex, COUNT(user_id) AS users_count
    FROM users
    GROUP BY sex
) AS subquery
WHERE sex = 'male'
в подзапросе мы сначала сгруппировали наши данные по полу и посчитали число пользователей в каждой группе, а потом обратились к результату этого подзапроса, как к таблице, и отобрали с помощью WHERE нужную нам группу.

К колонкам из подзапроса можно применять агрегирующие функции — так же, как если бы мы обращались к колонкам исходных таблиц:
SELECT MAX(column_sum) AS max_sum
FROM (
    SELECT column_1, SUM(column_2) AS column_sum
    FROM table
    GROUP BY column_1
) AS subquery_1

в SQL предусмотрен оператор WITH, который позволяет создавать так называемые табличные выражения (CTE, common table expressions).

Табличные выражения — это временные таблицы, существующие только для одного запроса. Их основное предназначение заключается в разбиении сложных запросов на несколько частей.

Табличные выражения создаются так:
WITH 
subquery_1 AS (
    SELECT column_1, column_2
    FROM table
)
Оператор WITH может содержать несколько табличных выражений, причём к указанным ранее выражениям можно обращаться в последующих выражениях:
WITH 
subquery_1 AS (
    SELECT column_1, column_2, column_3
    FROM table
),
subquery_2 AS (
    SELECT column_1, column_2
    FROM subquery_1
)

SELECT column_1
FROM subquery_2

Результат подзапроса, возвращающего столбец с одним значением, также можно использовать в арифметических операциях
SELECT column
FROM table
WHERE column = (SELECT MAX(column) FROM table) - 100

Более того, с помощью подзапросов вы можете брать необходимые вам значения из нескольких разных таблиц и использовать их в качестве переменных внутри основного запроса:
SELECT column
FROM table
WHERE column >= (SELECT MAX(column_1) FROM table_1) - 100
    AND column <= (SELECT MAX(column_2) FROM table_2)

Если же в одном запросе используется несколько разных «переменных» из подзапросов или к одному и тому же подзапросу нужно обращаться несколько раз, тогда имеет смысл вынести эти подзапросы в начало основного запроса в виде табличных выражений в блоке WITH.
WITH 
subquery AS (
    SELECT MAX(column_2)
    FROM table_2
)

SELECT column_1
FROM table_1
WHERE column_1 = (SELECT * FROM subquery) 

Обратите внимание на запись со «звёздочкой». Дело в том, что обратиться к этим «переменным» просто по имени табличного выражения не получится — придётся отдельным подзапросом из табличного выражения выбрать рассчитанное значение. Самый простой вариант — написать подзапрос с SELECT * из табличного выражения. 

Если «переменных» несколько, то запрос может выглядеть так:
WITH
subquery_1 AS (
    SELECT MAX(column_1)
    FROM table_1
),
subquery_2 AS (
    SELECT MAX(column_2)
    FROM table_2
)


SELECT column
FROM table
WHERE column >= (SELECT * FROM subquery_1) - 100
    AND column <= (SELECT * FROM subquery_2)

Чтобы отложить от даты или прибавить к ней какой-то промежуток времени, можно использовать несложные арифметические операции с датами. Например, от текущей даты можно отнять заданный промежуток INTERVAL:
SELECT NOW() - INTERVAL '1 year 2 months 1 week'
Результат:
10/10/21 19:32

Кстати, NOW — полезная функция, которая позволяет получать текущую дату и время (в вашем случае она будет другой, как и результат запроса выше):
SELECT NOW()
Результат:
17/12/22 19:32

С другими примерами работы с INTERVAL и арифметическими операциями с датами можно ознакомиться здесь-
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-interval/
Про функцию NOW можно дополнительно почитать тут-
https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-now/

подзапросы могут выступать в качестве аргументов функций, т.е. к результату выполнения подзапросов можно применять функции, принимающие на вход какие-то значения. Так, например, подзапросы можно указывать в качестве аргументов функций CONCAT или COALESCE:
SELECT CONCAT(
              'Начало периода: ', (SELECT MIN(date) FROM table), 
              ' ', 
              'Конец периода: ', (SELECT MAX(date) FROM table)
       )
SELECT COALESCE((SELECT MAX(date) FROM table), NOW())
В таком случае результат выполнения подзапроса будет подставляться в функцию для дальнейших расчётов.

Подзапрос, возвращающий несколько значений, может использоваться в блоке WHERE совместно с оператором IN — например, когда нам нужно проверить, совпадает ли значение в столбце с одним из значений из определённого множества, полученного в результате выполнения подзапроса:
SELECT column_1
FROM table_1
WHERE column_1 IN (SELECT column_2 FROM table_2) 
Сначала подзапрос отберёт все значения в колонке column_2 из таблицы table_2, а затем выберет те записи из таблицы table_1, где в колонке column_1 значение совпадает с одним из значений в колонке column_2, полученной в результате подзапроса. Обратите внимание, что использовать DISTINCT в подзапросе необязательно, т.к. на результат основного запроса это никак не повлияет — по большому счёту нет разницы, будут значения в списке уникальными или нет.

При этом запрос выше будет равносилен запросу с табличным выражением:
WITH 
subquery AS (
    SELECT column_2
    FROM table_2
)

SELECT column_1
FROM table_1
WHERE column_1 IN (SELECT * FROM subquery) 

На практике подзапрос в SELECT может использоваться для того, чтобы сравнить значения в колонке с каким-нибудь одним расчётным значением (из той же или другой таблицы):
SELECT column_1, column_2, column_2 > (SELECT MAX(column_1) FROM table) AS column_3
FROM table

Допустим, у нас есть две таблицы, в которых хранятся почты старых и новых клиентов, и нам необходимо «подтянуть» эту информацию в таблицу c заказами. Сделать это можно так:
SELECT client_id, email, order_id,
    CASE 
    WHEN email IN (SELECT email FROM clients_new)
    THEN 'new'
    WHEN email IN (SELECT email FROM clients_old)
    THEN 'old'
    ELSE 'unknown'
    END AS client_type
FROM orders

Подзапросы можно также использовать и в операторе FILTER для формирования ещё более продвинутых условий фильтрации. В таком случае конструкция будет иметь следующий вид:
SELECT COUNT(column) FILTER (WHERE column > (SELECT AVG(column) FROM table)) AS count
FROM table

Такой запрос посчитает количество значений в колонке column, которые превышают среднее значение по этой же колонке. Разумеется, в подзапросе, указанном в FILTER, можно обращаться и к другим колонкам и таблицам, применяя любые другие способы фильтрации — например, оператор IN:
SELECT COUNT(column_1) FILTER (WHERE column_1 IN (SELECT column_2 FROM table_2)) AS count
FROM table_1